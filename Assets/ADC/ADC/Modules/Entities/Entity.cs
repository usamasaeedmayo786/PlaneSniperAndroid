using System.Collections.Generic;
using UnityEngine;
using SimpleJSON;
using NaughtyAttributes;
#if UNITY_EDITOR
using UnityEditor;
#endif


/// <summary>
/// Entities represent dynamic game objects, they contain modules and are inherantly serialzable & saveable/loadable
/// </summary>
public partial class Entity : MonoBehaviour, ISaveLoad, IJsonSerializable
{

    // Public

    [Header("Base Entity Setup")]

    public bool useAutomaticID = true;

    [HideIf("useAutomaticID")] 
    public string id = "";          // having a unique id string for everything is generally useful

    [ShowNativeProperty]
    string autoGeneratedID => id;

    // Accessors

    /// <summary>
    /// The place that any built-in transfer animations use for this entity
    /// </summary>
    public virtual Transform transferAnimationTransform => transform;

    // Modules

    /// <summary>
    /// A list of modules used by the BaseEntity, used when saving + loading
    /// </summary>
    protected List<EntityModule> entityModules = new List<EntityModule>();

    /// <summary>
    /// Initialises a module. If it has not been set in the inspector, it tries GetComponentsInChildren(false), else it calls AddComponent to create it
    /// Note: Adds the module to entityModules list
    /// </summary>
    /// <typeparam name="T"></typeparam>
    /// <param name="module"></param>
    /// <returns></returns>
    protected virtual T InitializeModule<T>(EntityModule module) where T : Component
    {
        // 1. if the module does not exist, try to find it
        if (module == null)
        {
            module = gameObject.GetComponentInChildren<T>(false) as EntityModule;
        }
        // 2. if it still does not exist, add it
        if (module == null)
        {
            module = gameObject.AddComponent<T>() as EntityModule;
        }
        // 3. Initialize it
        if (module != null)
        {
            module.Initialize((Entity)this);
            entityModules.Add(module);
        }
        else
        {
            Debug.LogError($"Failed To Initialize Module of type '{typeof(T)}'");
        }

        return module as T;
    }

    // Automatic ID

#if UNITY_EDITOR
    bool isGeneratingID = false;

    public void GenerateID()
    {
        SerializedObject serializedObject = new SerializedObject(this);
        SerializedProperty idProperty = serializedObject.FindProperty("id");
        idProperty.stringValue = System.Guid.NewGuid().ToString();
        serializedObject.ApplyModifiedProperties();
    }

    public void SetNullID()
    {
        SerializedObject serializedObject = new SerializedObject(this);
        SerializedProperty idProperty = serializedObject.FindProperty("id");
        idProperty.stringValue = "";
        serializedObject.ApplyModifiedProperties();
    }

#if UNITY_EDITOR
    private void OnValidate() => UnityEditor.EditorApplication.delayCall += _OnValidate;

    private void _OnValidate()
    {
        UnityEditor.EditorApplication.delayCall -= _OnValidate;
        if (this == null) return;
        ValidateID();
    }
#endif

    private void ValidateID()
    {
        SerializedObject serializedObject = new SerializedObject(this);
        SerializedProperty idProperty = serializedObject.FindProperty("id");

        if (Application.isPlaying) return;
        if (!useAutomaticID) return;

        // When in prefab mode, we only need to reset an ID of the actual prefab being edited. Leave other id's alone so as to not generate overrides
        if (GameUtil.IsPrefabMode() || GameUtil.IsEditingPrefabInAssetFolder(gameObject))
        {
            // We delay the call here so that IsEditingPrefab has a chance of working correctly
            //EditorApplication.delayCall += () => {
                try
                {
                    if (GameUtil.IsEditingPrefab(gameObject) || GameUtil.IsEditingPrefabInAssetFolder(gameObject))
                    {
                        //Debug.Log($"we are editing the prefab '{name}'");

                        if (!string.IsNullOrEmpty(idProperty.stringValue))
                        {
                            Debug.Log($"On entering prefab mode, entity ({name}) has a non-null id whcih has been reset ({idProperty.stringValue})");
                            SetNullID();
                        }
                    } 
                }
                catch
                {
                    // Note we are catching the error case of inspectors updating after a save, where gameObject == null
                }
            //};

            return;
        }

        // Null id's when duplicating or copying
            
        // * this is a good general idea, but onvalidate fires for *everything* during a duplicate...
        Event e = Event.current;
        if (e != null && (e.commandName == "Duplicate" || e.commandName == "Paste") && new List<GameObject>(Selection.gameObjects).Contains(gameObject))
        {
            if (isGeneratingID) return;
            isGeneratingID = true;

            Debug.Log($"Setting a new ID during duplcate or paste ({name}-{idProperty.stringValue})");

            EditorApplication.delayCall += () =>
            {
                GenerateID();
                isGeneratingID = false;
            };
        }
            
            

        // Generate ID's for scene objects
        if (string.IsNullOrEmpty(idProperty.stringValue))
        {
            Debug.Log($"Generating a new ID for entity ({name}) event: ({(e == null ? "" : e.commandName)})");
            GenerateID();
        }
            
    }
#endif

    // Unity

    /// <summary>
    /// Base Entity Awake() loads entity + all module data
    /// </summary>
    protected virtual void Awake()
    {
        Load();
    }

    /// <summary>
    /// Does nothing. Reserved for future use
    /// </summary>
    protected virtual void Start()
    {

    }

    /// <summary>
    /// ID Generation (Editor only)
    /// </summary>
#if UNITY_EDITOR

#endif

    //ISaveLoad

    /// <summary>
    /// Iterates all listed modules, calling Save
    /// </summary>
    public virtual void Save()
    {
        // Save entity data (if there is something more than "{}" to save)
        if (SerializeJSON().ToString().Length > 2)
            Database.Write(id, "saveData", SerializeJSON().ToString());

        // Cause modules to save
        entityModules.ForEach(module => module.Save());
    }

    /// <summary>
    /// Iterates all listed modules, calling Load
    /// </summary>
    public virtual void Load()
    {
        // Load entity data
        string data = Database.Read<string>(id, "saveData");
        if (!string.IsNullOrEmpty(data)) DeserializeJSON(JSON.Parse(data));

        // Cause modules to load
        entityModules.ForEach(module => module.Load());
    }


    // IJsonSerialzable

    /// <summary>
    /// Default implementation returns an empty JSONObject
    /// </summary>
    /// <returns></returns>
    public virtual JSONNode SerializeJSON()
    {
        return new JSONObject();
    }

    /// <summary>
    /// Default implementation does nothing
    /// </summary>
    /// <param name="data"></param>
    public virtual void DeserializeJSON(JSONNode data)
    {

    }
}

